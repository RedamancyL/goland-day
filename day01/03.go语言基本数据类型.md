# 一. 基本数据类型
## 1.整型
整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64

其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型。


| 类型        | 描述         |
| ------------- |:-------------:
|uint8	无符号   | 8位整型 (0 到 255)
|uint16 无符号   |16位整型 (0 到 65535)
|uint32	无符号   |32位整型 (0 到 4294967295)
|uint64	无符号   |64位整型 (0 到 18446744073709551615)
|int8	有符号   |8位整型 (-128 到 127)
|int16	有符号   |16位整型 (-32768 到 32767)
|int32	有符号   |32位整型 (-2147483648 到 2147483647)
|int64	有符号   |64位整型 (-9223372036854775808 到 9223372036854775807)


## 2.特殊整型

| 类型        | 描述         |
| ------------- |:-------------:
|uint	        |32位操作系统上就是uint32，64位操作系统上就是uint64
|int	        |32位操作系统上就是int32，64位操作系统上就是int64
|uintptr	    |无符号整型，用于存放一个指针


注意： 在使用int和 uint类型时，不能假定它是32位或64位的整型，而是考虑int和uint可能在不同平台上的差异。

## 3.浮点型

Go语言支持两种浮点型数：float32和float64

打印浮点数时，可以使用fmt包配合动词%f 如：
```
package main

import "fmt"

//浮点数

func main() {
	// math.MaxFloat32 // floot32最大值
	f1 := 1.23456
	fmt.Printf("%T\n", f1) // 默认Go语言中的小数都是float64类型
	f2 := float32(1.23456)
	fmt.Printf("%T\n", f2) // 显示声明float32类型
	// f1 = f2 类型不同不能相互赋值
}
```

## 4.复数 (一般不用)

complex64和complex128
```
var c1 complex64
c1 = 1 + 2i
var c2 complex128
c2 = 2 + 3i
fmt.Println(c1)
fmt.Println(c2)
```
复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。

## 5. 布尔值

Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true（真）和false（假）两个值。

```
package main

import "fmt"

func main() {
	b1 := true
	var b2 bool // 默认false
	fmt.Printf("%T\n", b1)
	fmt.Printf("%T value:%v\n", b2, b2)
}
```
## 6. 字符串
Go语言中字符串是用双引号包裹的！！！

Go语言中单引号包裹的是字符！！！

```
// 字符串
s := "hello 世界"

// 单独的字母、汉字、符号表示一个字符
c1 := 'h'
c2 := 'e'
c3 := '世'

// 字节：1字节=8bit（8个二进制）
// 1个字符'A'=1个字节
// 1个utf8编码的汉字 '沙'= 一般占3个字节
```

- 字符串转义符

Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。

| 转义符        | 含义         |
| ------------- |:-------------:
|\r			    |回车符（返回行首）
|\n				|换行符（直接跳到下一行的同列位置）
|\t				|制表符
|\'				|单引号
|\"				|双引号
|\\				|反斜杠
如：打印一个centOS下的一个文件路径：
```
package main
import (
    "fmt"
)
func main() {
    fmt.Println("str := \"home\admin\users.sql"")
}
```
- 多行字符串
Go语言中要定义一个多行字符串时，就必须使用反引号字符：
```
s1 := `第一行
第二行
第三行
`
fmt.Println(s1)
```
反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。

-  字符串的常用操作
  
| 方法        | 介绍         |
| ------------- |:-------------:
|len(str)		|求长度
|+或fmt.Sprintf	|拼接字符串
|strings.Split	|分割
|strings.Contains	|判断是否包含
|strings.HasPrefix,strings.HasSuffix	|前缀/后缀判断
|strings.Index(),strings.LastIndex()	|子串出现的位置
|strings.Join(a[]string, sep string)	|join操作


## 7. byte和rune类型
组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：
```
var a := '中'
var b := 'x'
```
- Go 语言的字符有以下两种：

- 1。 uint8类型，或者叫 byte 型，代表了ASCII码的一个字符。
- 2。 rune类型，代表一个 UTF-8字符。
当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型实际是一个int32。

Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。

```
package main
import "fmt"

func main() {
	s := "hello 世界"

	for i := 0; i < len(s); i++ { //byte
		fmt.Printf("%v(%c) ", s[i], s[i])
	}
	fmt.Println()

	// len()求得时byte字节的数量
	n := len(s)

	fmt.Println(n)

	for _, c := range s {
		// fmt.Println(c)
		fmt.Printf("%c\n", c)
	}
}
```
输出
```
104(h) 101(e) 108(l) 108(l) 111(o) 32( ) 228(ä) 184(¸) 150() 231(ç) 149() 140() 
12
h
e
l
l
o
 
世
界
```
因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。

字符串底层是一个byte数组，所以可以和[]byte类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。

## 8. 修改字符串
要修改字符串，需要先将其转换成[] rune或[] byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组。
```
	// 修改字符串
	s2 := "白萝卜" //把字符强制转换成一个rune切片
	s3 := []rune(s2) // ===》 ["白" "萝" "卜"]
	s3[0] = '红' // 双引号表示字符串 ，单引号标示字符
	fmt.Println(string(s3))
```

## 9. 类型转换
Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。
```
	// 类型转换
	n1 := 10 //int
	var f float64
	f = float64(n1)
	fmt.Println(f)
	fmt.Printf("%T\n", f)

	输出：
		10
		float64
```
只有整型和浮点型，字符串和切片rune转换。

注意：
1. 布尔类型变量的默认值为false。
2. Go 语言中不允许将整型强制转换为布尔型.
3. 布尔型无法参与数值运算，也无法与其他类型进行转换。
4. Go语言中字符串是用双引号包裹的，go语言中单引号包裹的是字符。
```
   	c1 := "红" // string
	c2 := '红' // int32
	fmt.Printf("c1:%T c2:%T\n", c1, c2)

	c3 := "H" // string
	c4 := byte('H') // byte(int32)
	fmt.Printf("c1:%T c2:%T\n", c3, c4)

	输出：
		c1:string c2:int32
		c1:string c2:uint8
		
```
